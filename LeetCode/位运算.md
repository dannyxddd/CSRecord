# 位运算

<!-- GFM-TOC -->
* [1. 数字的32位二进制翻转](#1-数字的32位二进制翻转)
* [2. 正整数的反码](#2-正整数的反码)
* [3. 数的二进制中1的个数](#3-数的二进制中1的个数)
* [4. 两个数的汉明距离](#4-两个数的汉明距离)

<!-- GFM-TOC -->
并集 A | B 保持尽可能多的1位
交集 A & B 只选择某些位
异或 A ^ B 删除偶数个完全相同的数字并保存奇数个数字，或保存不同的位并删除相同的位。
所有位取反 ^A or ~A
减法 A & ~B
设置位 A |= 1 << bit
清楚位 A &= ~(1 << bit)
测试位 (A & 1 << bit) != 0
提取最后一位 A&-A or A&~(A-1) or x^(x&(x-1))
删除最后一位 A&(A-1)
得到所有1位 ~0
Tip：向左（或向右）移动太多后的结果是不确定的；对负值的右移操作是不确定的；移位中的右操作数应为非负数，否则结果不确定
    ＆和|运算符的优先级低于比较运算符

## 1. 数字的32位二进制翻转
### [190. Reverse Bits(Easy)](https://leetcode.com/problems/reverse-bits/)

题意：给定无符号数字，将数字的32位二进制从左到右的输入翻转成从右向左的输出。

```html
Example 1:
Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, 
so return 964176192 which its binary representation is 00111001011110000010100101000000.
```

解法：N无符号右移，结果带符号左移

```java
public int reverseBits(int n) {
    int result=0;
    for(int i=0;i<32;i++){
        result+=n&1; 
        n>>>=1;
        if(i<31) result<<=1;
    }
    return result;
}
```

### [7.Reverse Integer(Easy)](https://leetcode.com/problems/reverse-integer/) 

190题的类似题型：给定有符号数字，逆转数字，将数字的十进制从左到右的输入翻转成从右向左的输出。

```html
Example 1:
Input: 123
Output: 321

Example 2:
Input: -123
Output: -321
```

解法：注意溢出的判断

```java
public int reverse(int x) {
    int result = 0;
    while (x != 0){
        int a=x%10; int b=result*10+a;
        if((b-a)/10!=result)//考虑溢出
            return 0;
        result=b; x = x / 10;
    }
    return result;
}
```

## 2. 正整数的反码
### [476. Number Complement(Easy)](https://leetcode.com/problems/number-complement/)

题意：求正整数的反码，每位取反

```html
Example 1:
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), 
and its complement is 010. So you need to output 2.
```

解法：用循环，将最后一位置位

```java
public int findComplement(int num) {
    int result=0,count=0;
    while(num!=0){
        result|=(((~num)&1)<<count);
        count++; num>>>=1;
    }
    return result;
}
```

## 3. 数的二进制中1的个数
### [191. Number of 1 Bits(Easy)](https://leetcode.com/problems/number-of-1-bits/)

题意：求数的二进制中1的个数

```html
Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
```

解法：用n&(n-1)直到n为0，循环次数就是1的个数。

```java
public int hammingWeight(int n) {
    int count=0;
    while(n!=0) {
        n=n&(n-1);
        count++;
    }
    return count;
}
```

### [338. Counting Bits(Medium)](https://leetcode.com/problems/counting-bits/)

191题的类似题型：给定数n，求0～n每个数的二进制1的个数

```html
Example 1:
Input: 2
Output: [0,1,1]

Example 2:
Input: 5
Output: [0,1,1,2,1,2]
```
解法：DP+位运算dp[i]=dp[i>>1]+(i&1); 位运算代替除法和取模

```java
public int[] countBits(int num) {
    int[] res=new int[num+1];
    for(int i=0;i<=num;i++) 
        res[i]=res[i>>1]+(i&1);
    return res;   
}
```

## 4. 两个数的汉明距离
### [461. Hamming Distance(Easy)](https://leetcode.com/problems/hamming-distance/)

题意：求两个数的二进制不同位的个数

```html
Example:
Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
The above arrows point to positions where the corresponding bits are different.
```
解法：n = x ^ y消除相同位，得到两个数的不同位，再找1的个数

```java
public int hammingDistance(int x, int y) {
    int count = 0, n = x ^ y;//异或找不同位数  
    while(n!=0) {//找1的个数
        n=n&(n-1); 
        count++;
    }
    return count;  
}
```

### [477. Total Hamming Distance(Medium)](https://leetcode.com/problems/total-hamming-distance/)

461题的类似题型：求一组数中每两个数的不同位的个数总和

```html
Example:
Input: 4, 14, 2
Output: 6
Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case). So the answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
```

解法：统计出每一位的1的个数，0的个数乘以1的个数

```java
public int totalHammingDistance(int[] nums) {
    int sum = 0;
    for(int j=0;j<32;j++){
        int countone=0;//统计第j位的1的个数
        for(int i=0;i<nums.length;i++)
            countone += (nums[i]>>j)&1;//若数的二进制第j位为1，则统计
        sum+=countone*(nums.length-countone);//每一位中的0的个数乘以1的个数
    }
    return sum;
}
```
