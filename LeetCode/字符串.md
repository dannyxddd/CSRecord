# 字符串匹配/组合题型

<!-- GFM-TOC -->
* [1. 判断两个字符串是否匹配](#1-判断两个字符串是否匹配)
    * [10. Regular Expression Matching(Hard)](#10-Regular Expression Matching(Hard))
    * [44. Wildcard Matching(Hard)](#44-Wildcard Matching(Hard))
<!-- GFM-TOC -->

> 关于字符串之间的变换字符让其匹配、组合成新串、共同前缀等类型的题，要优先考虑用DP。

## 1. 判断两个字符串是否匹配
### [10. Regular Expression Matching(Hard)](https://leetcode.com/problems/regular-expression-matching/)

题意：判断两个字符串是否匹配，"."可以匹配一个字符，"*"可以匹配前一个字符的任意个字符

```html
Input: s = "aab" p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
```
解法：用DP，判断后一个字符是否为"*"，两种情况分开考虑

```java
public boolean isMatch(String s, String p) {
    if(p.isEmpty()) return s.isEmpty();
    int n=s.length(),m=p.length();
    boolean dp[][]=new boolean[n+1][m+1];
    dp[n][m]=true;
    for(int i=n;i>=0;i--){
        for(int j=m-1;j>=0;j--){
            if(j+1<m&&p.charAt(j+1)=='*'){//后一个字符是*
                if(i<n&&(s.charAt(i)==p.charAt(j)||p.charAt(j)=='.'))
                    dp[i][j]=dp[i+1][j] || dp[i][j+2];
                else
                    dp[i][j]=dp[i][j+2];
            }else{//后一个字符不是*
                if(i<n&&(s.charAt(i)==p.charAt(j)||p.charAt(j)=='.'))
                    dp[i][j]=dp[i+1][j+1];
            }
        }
    }
    return dp[0][0];
}
```
### [44. Wildcard Matching(Hard)](https://leetcode.com/problems/wildcard-matching/)

题意：判断两个字符串是否匹配，"?"可以匹配一个字符，"*"可以匹配任意个字符(不一定要和前一个字符相同)

```html
Input: s = "adceb"  p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
```
解法：用DP，最后一位为"*"的全部设为true，之后从后往前考虑当前字符是"?"还是"*"

```java
public boolean isMatch(String s, String p) {
    int n=s.length(),m=p.length();
    boolean dp[][]=new boolean[n+1][m+1];
    dp[n][m]=true;
    for(int i=m-1;i>=0;i--){//将最后一位为*的全部设为true
        if(p.charAt(i)!='*') break;
        else dp[n][i]=true;
    }
    for(int i=n-1;i>=0;i--){
        for(int j=m-1;j>=0;j--){//当前字符相等或者是“？”
            if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')
                dp[i][j]=dp[i+1][j+1];
            else if(p.charAt(j)=='*')//当前字符是*
                dp[i][j]=dp[i+1][j]||dp[i][j+1];
        }
    }
    return dp[0][0];
}
```

## 2. 两个字符串的编辑距离
### [72. Edit Distance(Hard)](https://leetcode.com/problems/edit-distance/)

题意：求两个字符串之间的最短编辑距离，即通过增/删/改最少的字符数量使得两个字符串相同

```html
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
```
解法：用DP，先初始化dp[i][0]=i;dp[0][i]=i;

```java
public int minDistance(String word1, String word2) {
    int m=word1.length(),n=word2.length();
    int dp[][]=new int[m+1][n+1];
    for(int i=0;i<=m;i++) 
        dp[i][0]=i;		
    for(int i=0;i<=n;i++) 
        dp[0][i]=i;

    for(int i=1;i<=m;i++) {
        for(int j=1;j<=n;j++) {
            if(word1.charAt(i-1)==word2.charAt(j-1)) //字符相等
                dp[i][j]=dp[i-1][j-1];
            else //删一个/加一个/改一个
                dp[i][j]=Math.min(Math.min(dp[i-1][j], dp[i][j-1]),dp[i-1][j-1])+1;
        }
    }		
    return dp[m][n];
```
