# 字符串匹配/组合题型

<!-- GFM-TOC -->
* [1. 判断两个字符串是否匹配](#1-判断两个字符串是否匹配)
<!-- GFM-TOC -->

关于字符串之间的变换字符让其匹配、组合成新串、共同前缀等类型的题，要优先考虑用DP。

## 1. 判断两个字符串是否匹配

### [10. Regular Expression Matching(Hard)](https://leetcode.com/problems/regular-expression-matching/)

```html
Input: s = "aab" p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
```

题意：判断两个字符串是否匹配，“.”可以匹配一个字符，“*&”可以匹配前一个字符的任意个字符

主要思想：用DP，判断后一个字符是否为"*"，两种情况分开考虑

```java
public boolean isMatch(String s, String p) {
    if(p.isEmpty()) return s.isEmpty();
    int n=s.length(),m=p.length();
    boolean dp[][]=new boolean[n+1][m+1];
    dp[n][m]=true;
    for(int i=n;i>=0;i--){
        for(int j=m-1;j>=0;j--){
            if(j+1<m&&p.charAt(j+1)=='*'){//后一个字符是*
                if(i<n&&(s.charAt(i)==p.charAt(j)||p.charAt(j)=='.'))
                    dp[i][j]=dp[i+1][j] || dp[i][j+2];
                else
                    dp[i][j]=dp[i][j+2];
            }else{//后一个字符不是*
                if(i<n&&(s.charAt(i)==p.charAt(j)||p.charAt(j)=='.'))
                    dp[i][j]=dp[i+1][j+1];
            }
        }
    }
    return dp[0][0];
}
```
### [44. Wildcard Matching(Hard)](https://leetcode.com/problems/wildcard-matching/)

```html
Input: s = "adceb"  p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
```

题意：判断两个字符串是否匹配，“？”可以匹配一个字符，“*&”可以匹配任意个字符(不一定要和前一个字符相同)

主要思想：用DP，最后一位为“*&”的全部设为true，之后从后往前考虑当前字符是“？”还是“*”

```java
public boolean isMatch(String s, String p) {
    int n=s.length(),m=p.length();
    boolean dp[][]=new boolean[n+1][m+1];
    dp[n][m]=true;
    for(int i=m-1;i>=0;i--){//将最后一位为*的全部设为true
        if(p.charAt(i)!='*') break;
        else dp[n][i]=true;
    }
    for(int i=n-1;i>=0;i--){
        for(int j=m-1;j>=0;j--){//当前字符相等或者是“？”
            if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')
                dp[i][j]=dp[i+1][j+1];
            else if(p.charAt(j)=='*')//当前字符是*
                dp[i][j]=dp[i+1][j]||dp[i][j+1];
        }
    }
    return dp[0][0];
}
```
